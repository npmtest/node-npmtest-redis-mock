{"/home/travis/build/npmtest/node-npmtest-redis-mock/test.js":"/* istanbul instrument in package npmtest_redis_mock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - init-after\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - init-after\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-redis-mock/lib.npmtest_redis_mock.js":"/* istanbul instrument in package npmtest_redis_mock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_redis_mock = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_redis_mock = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-redis-mock/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-redis-mock && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_redis_mock */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - init-before\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_redis_mock\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // init-after\n    // run browser js-env code - init-after\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - init-after\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_redis_mock.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_redis_mock.rollup.js'] =\n            local.assetsDict['/assets.npmtest_redis_mock.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_redis_mock.__dirname + '/lib.npmtest_redis_mock.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/redis-mock.js":"/**\n * Module dependencies\n */\nvar events = require(\"events\"),\n  util = require(\"util\");\n\n\nvar parseArguments = function(args) {\n  var arr,\n      len = args.length,\n      callback,\n      i = 0;\n  if (Array.isArray(args[0])) {\n    // arg0 = [hash, k1, v1, k2, v2,]\n    // arg1 = callback\n    arr = args[0];\n    callback = args[1];\n  } else if (Array.isArray(args[1])) {\n    // arg0 = hash\n    // arg1 = [k1, v1, k2, v2,]\n    // arg2 = callback\n    if (len === 3) {\n      callback = args[2];\n    }\n    len = args[1].length;\n    arr = new Array(len + 1);\n    arr[0] = args[0];\n    for (; i < len; i += 1) {\n      arr[i + 1] = args[1][i];\n    }\n  } else if (typeof args[1] === 'object' &&\n    (args.length === 2 || args.length === 3 &&\n      (typeof args[2] === 'function' || typeof args[2] === 'undefined'))) {\n        // arg0 = hash\n        // arg1 = {k1: v1, k2: v2,}\n        // arg2 = callback\n        arr = [args[0]];\n        for (var field in args[1]) {\n            arr.push(field, args[1][field]);\n        }\n        callback = args[2];\n  } else {\n    // arg0 = hash\n    // arg1..N-1 = k1,v1,k2,v2,...N-1\n    // argN = callback\n    len = args.length;\n    // The later should not be the average use case\n    if (len !== 0 && (typeof args[len - 1] === 'function' || typeof args[len - 1] === 'undefined')) {\n      len--;\n      callback = args[len];\n    }\n    arr = new Array(len);\n    for (; i < len; i += 1) {\n      arr[i] = args[i];\n    }\n  }\n  if (callback) {\n    arr.push(callback);\n  }\n\n  return arr;\n}\n\n/**\n * RedisMock constructor\n */\nfunction RedisMock() {\n\n  this.storage = {};\n\n  var self = this;\n\n  /**\n   * Helper function to launch the callback(err, reply)\n   * on the next process tick\n   */\n  this._callCallback = function (callback, err, result) {\n    if (callback) {\n      process.nextTick(function () {\n        callback(err, result);\n      });\n    }\n  };\n}\n\n/**\n * RedisMock inherits from EventEmitter to be mock pub/sub\n */\nutil.inherits(RedisMock, events.EventEmitter);\n\n/*\n * Create RedisMock instance and export\n */\nvar MockInstance = new RedisMock();\nmodule.exports = exports = MockInstance;\n\n/**\n * RedisClient constructor\n */\nfunction RedisClient(stream, options) {\n\n  var self = this;\n\n  this.pub_sub_mode = false;\n\n\n  // We always listen for 'message', even if this is not a subscription client.\n  // We will only act on it, however, if the channel is in this.subscriptions, which is populated through subscribe\n  this._message = function (ch, msg) {\n\n    if (ch in self.subscriptions && self.subscriptions[ch] == true) {\n      self.emit('message', ch, msg);\n    }\n\n    Object.keys(self.psubscriptions).some(function(key) {\n      if(self.psubscriptions[key].test(ch)) {\n        self.emit('pmessage', key, key, msg);\n        return true;\n      }\n      return false;\n    });\n  }\n\n  MockInstance.on('message', this._message);\n\n  // Pub/sub subscriptions\n  this.subscriptions = {};\n  this.psubscriptions = {};\n\n  process.nextTick(function () {\n\n    self.emit(\"ready\");\n    self.emit(\"connect\");\n\n  });\n}\n\n/*\n * RedisClient inherits from EventEmitter\n */\nutil.inherits(RedisClient, events.EventEmitter);\n\n/**\n * Export the RedisClient constructor\n */\nRedisMock.prototype.RedisClient = RedisClient;\n\n/**\n * End\n */\nvar end = RedisClient.prototype.end = function () {\n\n  var self = this;\n\n  // Remove all subscriptions (pub/sub)\n  this.subscriptions = [];\n\n  //Remove listener from MockInstance to avoid 'too many subscribers errors'\n  MockInstance.removeListener('message', this._message);\n\n  // TODO: Anything else we need to clear?\n\n  process.nextTick(function () {\n\n    self.emit(\"end\");\n  });\n\n}\n\n/**\n * Quit\n */\nRedisClient.prototype.quit = end;\n\n/**\n * Publish / subscribe / unsubscribe\n */\nvar pubsub = require(\"./pubsub.js\");\nRedisClient.prototype.subscribe = pubsub.subscribe;\nRedisClient.prototype.psubscribe = pubsub.psubscribe;\nRedisClient.prototype.unsubscribe = pubsub.unsubscribe;\nRedisClient.prototype.punsubscribe = pubsub.punsubscribe;\nRedisClient.prototype.publish = function (channel, msg) {\n  pubsub.publish.call(this, MockInstance, channel, msg);\n}\n\n/**\n * multi\n */\nvar multi = require(\"./multi\");\nRedisClient.prototype.multi = multi;\n\n/**\n * Keys function\n */\n\nvar keyfunctions = require(\"./keys.js\");\nRedisClient.prototype.del = RedisClient.prototype.DEL = function (keys, callback) {\n\n  keyfunctions.del.call(this, MockInstance, keys, callback);\n};\n\nRedisClient.prototype.exists = RedisClient.prototype.EXISTS = function (key, callback) {\n\n  keyfunctions.exists.call(this, MockInstance, key, callback);\n};\n\nRedisClient.prototype.expire = RedisClient.prototype.EXPIRE = function (key, seconds, callback) {\n\n  keyfunctions.expire.call(this, MockInstance, key, seconds, callback);\n};\n\nRedisClient.prototype.ttl = RedisClient.prototype.TTL = function (key, callback) {\n\n  keyfunctions.ttl.call(this, MockInstance, key, callback);\n};\n\nRedisClient.prototype.keys = RedisClient.prototype.KEYS = function (pattern, callback) {\n\n  keyfunctions.keys.call(this, MockInstance, pattern, callback);\n};\n\nRedisClient.prototype.incr = RedisClient.prototype.INCR = function (key, callback) {\n\n  stringfunctions.incr.call(this, MockInstance, key, callback);\n};\n\nRedisClient.prototype.incrby = RedisClient.prototype.INCRBY = function (key, value, callback) {\n\n  stringfunctions.incrby.call(this, MockInstance, key, value, callback);\n};\n\nRedisClient.prototype.incrbyfloat = RedisClient.prototype.INCRBYFLOAT = function (key, value, callback) {\n\n  stringfunctions.incrbyfloat.call(this, MockInstance, key, value, callback);\n};\n\n/**\n * String function\n */\n\nvar stringfunctions = require(\"./strings.js\");\nRedisClient.prototype.get = RedisClient.prototype.GET = function (key, callback) {\n\n  stringfunctions.get.call(this, MockInstance, key, callback);\n};\n\nRedisClient.prototype.getset = RedisClient.prototype.GETSET = function (key, value, callback) {\n\n  stringfunctions.getset.call(this, MockInstance, key, value, callback);\n};\n\n//SET key value [EX seconds] [PX milliseconds] [NX|XX]\nRedisClient.prototype.set = RedisClient.prototype.SET = function (key, value, callback) {\n    var args = [];\n\n    for (var i = 0; i < arguments.length; i++) {\n        args.push(arguments[i]);\n    }\n\n    key = args.shift();\n    value = args.shift();\n    callback = args.pop();\n\n    var isEx = false;\n    var isPx = false;\n    var isNx = false;\n    var isXx = false;\n    var expireTime = 0;\n    var keyExists = false;\n    if (key in MockInstance.storage) {\n        keyExists = true;\n    }\n\n    if(args.length > 0) {\n        for (var i = 0; i < args.length; i++) {\n            if(typeof args[i] === 'string' &&  args[i].toLowerCase() === \"ex\") {\n                isEx = true;\n            } else if(typeof args[i] === 'string' && args[i].toLowerCase() === \"px\") {\n                isPx = true;\n            } else if(typeof args[i] === 'string' && args[i].toLowerCase() === \"nx\") {\n                isNx = true;\n            } else if(typeof args[i] === 'string' && args[i].toLowerCase() === \"xx\") {\n                isXx = true;\n            } else if(typeof args[i] === 'number' && args[i] % 1 === 0 ) {\n                expireTime = args[i];\n            }\n        }\n    }\n    if(isPx === true) {\n        expireTime = expireTime / 1000;\n        isEx = true;\n    }\n\n    if(isEx === true) {\n        if(isXx === true) {\n            if(keyExists === true) {\n                stringfunctions.set.call(this, MockInstance, key, value, function () {\n                  keyfunctions.expire.call(this, MockInstance, key, expireTime, function(err, result) {\n                      callback(err, \"OK\");\n                  });\n                });\n            } else {\n                MockInstance._callCallback(callback, null, 0);\n            }\n        } else if(isNx === true) {\n\n            if(keyExists === true) {\n                MockInstance._callCallback(callback, null, null);\n            } else {\n                stringfunctions.set.call(this, MockInstance, key, value, function () {\n                  keyfunctions.expire.call(this, MockInstance, key, expireTime, function(err, result) {\n                      callback(err, \"OK\");\n                  });\n                });\n            }\n        } else {\n            stringfunctions.set.call(this, MockInstance, key, value, function () {\n              keyfunctions.expire.call(this, MockInstance, key, expireTime, function(err, result) {\n                  callback(err, \"OK\");\n              });\n            });\n        }\n    } else {\n\n        if(isXx === true) {\n            if(keyExists === true) {\n                stringfunctions.set.call(this, MockInstance, key, value, callback);\n            } else {\n                MockInstance._callCallback(callback, null, null);\n            }\n        } else if(isNx === true) {\n            if(keyExists === true) {\n                MockInstance._callCallback(callback, null, 0);\n\n            } else {\n                stringfunctions.set.call(this, MockInstance, key, value, callback);\n            }\n        } else {\n            stringfunctions.set.call(this, MockInstance, key, value, callback);\n        }\n    }\n\n};\n\nRedisClient.prototype.ping = RedisClient.prototype.PING = function (callback) {\n\n  stringfunctions.ping.call(this, MockInstance, callback);\n};\n\nRedisClient.prototype.setex = RedisClient.prototype.SETEX = function (key, seconds, value, callback) {\n\n  stringfunctions.set.call(this, MockInstance, key, value, function () {\n    keyfunctions.expire.call(this, MockInstance, key, seconds, function(err, result) {\n      MockInstance._callCallback(callback, null, \"OK\");\n    });\n  });\n};\n\nRedisClient.prototype.setnx = RedisClient.prototype.SETNX = function (key, value, callback) {\n  stringfunctions.setnx.call(this, MockInstance, key, value, callback);\n};\n\nRedisClient.prototype.mget = RedisClient.prototype.MGET = function () {\n  var newArguments = [MockInstance];\n  for (var i = 0; i < arguments.length; i++) {\n    newArguments.push(arguments[i]);\n  }\n\n  stringfunctions.mget.apply(this, newArguments);\n};\n\n/**\n * Hashing functions\n */\nvar hashing = require(\"./hash.js\");\nRedisClient.prototype.hget = RedisClient.prototype.HGET = function (hash, key, callback) {\n\n  hashing.hget.call(this, MockInstance, hash, key, callback);\n}\nRedisClient.prototype.hexists = RedisClient.prototype.HEXISTS = function (hash, key, callback) {\n\n  hashing.hexists.call(this, MockInstance, hash, key, callback);\n}\nRedisClient.prototype.hdel = RedisClient.prototype.HDEL = function (hash, key, callback) {\n\n  hashing.hdel.call(this, MockInstance, hash, key, callback);\n}\nRedisClient.prototype.hset = RedisClient.prototype.HSET = function (hash, key, value, callback) {\n\n  hashing.hset.call(this, MockInstance, hash, key, value, callback);\n}\nRedisClient.prototype.hincrby = RedisClient.prototype.HINCRBY = function (hash, key, increment, callback) {\n\n  hashing.hincrby.call(this, MockInstance, hash, key, increment, callback);\n}\nRedisClient.prototype.hincrbyfloat = RedisClient.prototype.HINCRBYFLOAT = function (hash, key, increment, callback) {\n\n  hashing.hincrbyfloat.call(this, MockInstance, hash, key, increment, callback);\n}\n\nRedisClient.prototype.hsetnx = RedisClient.prototype.HSETNX = function (hash, key, value, callback) {\n\n  hashing.hsetnx.call(this, MockInstance, hash, key, value, callback);\n}\nRedisClient.prototype.hlen = RedisClient.prototype.HLEN = function (hash, callback) {\n\n  hashing.hlen.call(this, MockInstance, hash, callback);\n}\n\nRedisClient.prototype.hkeys = RedisClient.prototype.HKEYS = function (hash, callback) {\n\n  hashing.hkeys.call(this, MockInstance, hash, callback);\n}\nRedisClient.prototype.hvals = RedisClient.prototype.HVALS = function (hash, callback) {\n\n  hashing.hvals.call(this, MockInstance, hash, callback);\n}\nRedisClient.prototype.hmset = RedisClient.prototype.HMSET = function () {\n\n  var args = parseArguments(arguments);\n  hashing.hmset.apply(this, [MockInstance].concat(args));\n}\nRedisClient.prototype.hmget = RedisClient.prototype.HMGET = function () {\n\n  var newArguments = [MockInstance];\n  for (var i = 0; i < arguments.length; i++) {\n    newArguments.push(arguments[i]);\n  }\n\n  hashing.hmget.apply(this, newArguments);\n}\nRedisClient.prototype.hgetall = RedisClient.prototype.HGETALL = function (hash, callback) {\n\n  hashing.hgetall.call(this, MockInstance, hash, callback);\n}\n\n/**\n * List functions\n */\nvar listfunctions = require(\"./list.js\");\nRedisClient.prototype.llen = RedisClient.prototype.LLEN = function (key, callback) {\n  listfunctions.llen.call(this, MockInstance, key, callback);\n}\n\nRedisClient.prototype.lpush = RedisClient.prototype.LPUSH = function () {\n  var args = parseArguments(arguments);\n  listfunctions.lpush.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.rpush = RedisClient.prototype.RPUSH = function () {\n  var args = parseArguments(arguments);\n  listfunctions.rpush.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.lpushx = RedisClient.prototype.LPUSHX = function (key, value, callback) {\n  listfunctions.lpushx.call(this, MockInstance, key, value, callback);\n}\n\nRedisClient.prototype.rpushx = RedisClient.prototype.RPUSHX = function (key, value, callback) {\n  listfunctions.rpushx.call(this, MockInstance, key, value, callback);\n}\n\nRedisClient.prototype.lpop = RedisClient.prototype.LPOP = function (key, callback) {\n  listfunctions.lpop.call(this, MockInstance, key, callback);\n}\n\nRedisClient.prototype.rpop = RedisClient.prototype.RPOP = function (key, callback) {\n  listfunctions.rpop.call(this, MockInstance, key, callback);\n}\n\nvar bpop = function (fn, key, timeout, callback) {\n  var keys = [];\n  var hasCallback = typeof(arguments[arguments.length - 1]) === \"function\";\n  for (var i = 1; i < (hasCallback ? arguments.length - 2 : arguments.length - 1); i++) {\n    keys.push(arguments[i]);\n  }\n  if (hasCallback) {\n    fn.call(this, MockInstance, keys, arguments[arguments.length - 2], arguments[arguments.length - 1]);\n  } else {\n    fn.call(this, MockInstance, keys, arguments[arguments.length - 1]);\n  }\n}\n\nRedisClient.prototype.blpop = RedisClient.prototype.BLPOP = function (key, timeout, callback) {\n  var args = [listfunctions.blpop];\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n  bpop.apply(this, args);\n}\n\nRedisClient.prototype.brpop = RedisClient.prototype.BRPOP = function (key, timeout, callback) {\n  var args = [listfunctions.brpop];\n  for (var i = 0; i < arguments.length; i++) {\n    args.push(arguments[i]);\n  }\n  bpop.apply(this, args);\n}\n\nRedisClient.prototype.lindex = RedisClient.prototype.LINDEX = function (key, index, callback) {\n  listfunctions.lindex.call(this, MockInstance, key, index, callback);\n}\n\nRedisClient.prototype.lrange = RedisClient.prototype.LRANGE = function (key, index1, index2, callback) {\n  listfunctions.lrange.call(this, MockInstance, key, index1, index2, callback);\n}\n\nRedisClient.prototype.lset = RedisClient.prototype.LSET = function (key, index, value, callback) {\n  listfunctions.lset.call(this, MockInstance, key, index, value, callback);\n}\n\n/**\n * Set functions\n */\nvar setfunctions = require(\"./set.js\");\n\nvar getVarargs = function (args) {\n  var members = [];\n  var hasCallback = typeof(args[args.length - 1]) === 'function';\n  for (var i = 1; i < (hasCallback ? args.length - 1 : args.length); i++) {\n    members.push(args[i]);\n  }\n  var callback = hasCallback ? args[args.length - 1] : undefined;\n  return {members: members, callback: callback};\n}\n\nRedisClient.prototype.sadd = RedisClient.prototype.SADD = function (key, member, callback) {\n  var args = getVarargs(arguments);\n  setfunctions.sadd.call(this, MockInstance, key, args.members, args.callback);\n}\n\nRedisClient.prototype.srem = RedisClient.prototype.SREM = function (key, member, callback) {\n  var args = getVarargs(arguments);\n  setfunctions.srem.call(this, MockInstance, key, args.members, args.callback);\n}\n\nRedisClient.prototype.smembers = RedisClient.prototype.SMEMBERS = function (key, callback) {\n  setfunctions.smembers.call(this, MockInstance, key, callback);\n}\n\nRedisClient.prototype.scard = RedisClient.prototype.SCARD = function (key, callback) {\n  setfunctions.scard.call(this, MockInstance, key, callback);\n}\n\nRedisClient.prototype.sismember = RedisClient.prototype.SISMEMBER = function (key, member, callback) {\n  setfunctions.sismember.call(this, MockInstance, key, member, callback);\n}\n\n/**\n * SortedSet functions\n\n  *** NOT IMPLEMENTED ***\n  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n  ZLEXCOUNT key min max\n  ZRANGEBYLEX key min max [LIMIT offset count]\n  ZREVRANGEBYLEX key max min [LIMIT offset count]\n  ZREMRANGEBYLEX key min max\n  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n  ZSCAN key cursor [MATCH pattern] [COUNT count]\n*/\nvar sortedset = require(\"./sortedset.js\");\n\nRedisClient.prototype.zadd = RedisClient.prototype.ZADD = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zadd.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zcard = RedisClient.prototype.ZCARD = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zcard.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zcount = RedisClient.prototype.ZCOUNT = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zcount.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zincrby = RedisClient.prototype.ZINCRBY = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zincrby.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrange = RedisClient.prototype.ZRANGE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrange.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrangebyscore = RedisClient.prototype.ZRANGEBYSCORE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrangebyscore.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrank = RedisClient.prototype.ZRANK = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrank.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrem = RedisClient.prototype.ZREM = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrem.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zremrangebyrank = RedisClient.prototype.ZREMRANGEBYRANK = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zremrangebyrank.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zremrangebyscore = RedisClient.prototype.ZREMRANGEBYSCORE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zremrangebyscore.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrevrange = RedisClient.prototype.ZREVRANGE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrevrange.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrevrangebyscore = RedisClient.prototype.ZREVRANGEBYSCORE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrevrangebyscore.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zrevrank = RedisClient.prototype.ZREVRANK = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zrevrank.apply(this, [MockInstance].concat(args));\n}\n\nRedisClient.prototype.zscore = RedisClient.prototype.ZSCORE = function () {\n\n  var args = parseArguments(arguments);\n  sortedset.zscore.apply(this, [MockInstance].concat(args));\n}\n\n/**\n * Other commands (Lua scripts)\n */\n\nRedisClient.prototype.send_command = RedisClient.prototype.SEND_COMMAND = function (callback) {\n  if (typeof(arguments[arguments.length - 1]) == 'function') {\n    arguments[arguments.length - 1]();\n  }\n}\n\nRedisClient.prototype.select = function (database, callback) {\n\n  if (!isNaN(database)) {\n  return callback(null, \"OK\");\n  } else {\n    var error = new Error('ERR invalid DB index');\n    return callback(error, null);\n  }\n}\n\n/**\n * Server functions\n */\nvar serverfunctions = require(\"./server.js\");\nRedisClient.prototype.flushdb = RedisClient.prototype.FLUSHDB = function (callback) {\n\n  serverfunctions.flushdb.call(this, MockInstance, callback);\n}\nRedisClient.prototype.flushall = RedisClient.prototype.FLUSHALL = function (callback) {\n\n  serverfunctions.flushall.call(this, MockInstance, callback);\n}\n\nRedisClient.prototype.auth = RedisClient.prototype.AUTH = function (password, callback) {\n\n  serverfunctions.auth.call(this, MockInstance, password, callback);\n}\n\nRedisMock.prototype.createClient = function (port_arg, host_arg, options) {\n\n  return new RedisClient();\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/pubsub.js":"﻿/**\n * Subscribe\n *\n * TODO: Verify how multiple channel subscription works in actual Redis\n *   Optional callback?\n *\n */\n\nvar patternToRegex = require('./helpers').patternToRegex;\n\nexports.subscribe = function () {\n\n  var self = this;\n\n  if (!arguments.length) {\n    return;\n  }\n\n  this.pub_sub_mode = true;\n\n  for (var i = 0; i < arguments.length; i++) {\n\n    if ('string' == typeof arguments[i]) {\n\n      // Event on next tick to emulate an actual server call\n      var channelName = arguments[i];\n      process.nextTick(function () {\n        self.subscriptions[channelName] = true;\n        // TODO Should also send length of subscriptions here\n        self.emit('subscribe', channelName);\n      });\n    }\n  }\n}\n\n/**\n * pSubscribe\n */\nexports.psubscribe = function () {\n  var self = this;\n  if (!arguments.length) { return; }\n  this.pub_sub_mode = true;\n\n  for (var i = 0; i < arguments.length; i++) {\n    if ('string' == typeof arguments[i]) {\n      // Event on next tick to emulate an actual server call\n      var channelName = arguments[i];\n      process.nextTick(function () {\n        self.psubscriptions[channelName] = patternToRegex(channelName);\n        self.emit('psubscribe', channelName);\n      });\n    }\n  }\n}\n/**\n * Unsubscribe\n */\nexports.unsubscribe = function () {\n\n  var self = this\n    , subcriptions = arguments;\n\n  // TODO: Unsubscribe from ALL channels\n  if (!arguments.length) {\n    subcriptions = self.subscriptions.map(function (__, subscription) {\n      return subscription;\n    })\n  }\n\n  for (var i = 0; i < subcriptions.length; i++) {\n\n    if ('string' == typeof arguments[i]) {\n\n      // Event on next tick to emulate an actual server call\n      var channelName = arguments[i];\n      process.nextTick(function () {\n        self.subscriptions[channelName] = false;\n        delete self.subscriptions[channelName];\n        self.emit('unsubscribe', channelName);\n      });\n    }\n  }\n\n  // TODO: If this was the last subscription, pub_sub_mode should be set to false\n  this.pub_sub_mode = false;\n}\n\n/**\n * punsubscribe\n */\nexports.punsubscribe = function () {\n  var self = this\n    , subcriptions = arguments;\n\n  // Unsubscribe from ALL channels\n  if (!arguments.length) {\n    subcriptions = Object.keys(self.psubscriptions);\n    this.pub_sub_mode = false;\n  }\n\n  for (var i = 0; i < subcriptions.length; i++) {\n    if ('string' == typeof arguments[i]) {\n      // Event on next tick to emulate an actual server call\n      var channelName = arguments[i];\n      process.nextTick(function () {\n        delete self.psubscriptions[channelName];\n        self.emit('punsubscribe', channelName);\n      });\n    }\n  }\n  // TODO: If this was the last subscription, pub_sub_mode should be set to false\n}\n\n/**\n * Publish\n */\nexports.publish = function (mockInstance, channel, msg) {\n\n  this.pub_sub_mode = true;\n  process.nextTick(function () {\n    if ((typeof msg == \"object\") && (msg !== null)) {\n      msg = JSON.stringify(msg);\n    }\n    mockInstance.emit('message', channel, msg);\n  });\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/helpers.js":"var charMap = {\n  '?': '.',\n  '\\\\?': '\\\\?',\n  '*': '.*',\n  '\\\\*': '\\\\*',\n  '^': '\\\\^',\n  '[^': '[^',\n  '\\\\[^': '\\\\[\\\\^',\n  '$': '\\\\$',\n  '+': '\\\\+',\n  '.': '\\\\.',\n  '(': '\\\\(',\n  ')': '\\\\)',\n  '{': '\\\\{',\n  '}': '\\\\}',\n  '|': '\\\\|'\n};\n\nvar patternChanger = /\\\\\\?|\\?|\\\\\\*|\\*|\\\\\\[\\^|\\[\\^|\\^|\\$|\\+|\\.|\\(|\\)|\\{|\\}|\\|/g;\n\n/* Converting pattern into regex */\nexports.patternToRegex = function(pattern) {\n  var fixed = pattern.replace(patternChanger, function(matched) { return charMap[matched] });\n  return new RegExp('^' + fixed + '$');\n}\n\nvar mockCallback = exports.mockCallback = function(err, reply) {};\n\nvar parseCallback = exports.parseCallback = function(args) {\n  var callback;\n  var len = args.length;\n  if ('function' === typeof args[len - 1]) {\n    callback = args[len-1];\n  }\n  return callback;\n};\n\nvar validKeyType = exports.validKeyType = function(mockInstance, key, type, callback) {\n  if (mockInstance.storage[key] && mockInstance.storage[key].type !== type) {\n    var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n    mockInstance._callCallback(callback, err);\n    return false;\n  }\n  return true;\n};\n\nvar initKey = exports.initKey = function(mockInstance, key, fn) {\n  mockInstance.storage[key] = mockInstance.storage[key] || fn();\n};","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/multi.js":"\nvar Multi = function(client) {\n  this._client = client;\n  this._commands = [];\n  this._results = [];\n  this._errors = [];\n  this._unfinishedCount = 0;\n};\n\n/**\n * Add a new command to the queue\n */\nMulti.prototype._command = function(name, argList) {\n  var self = this;\n  var index = self._commands.length;\n\n  var callBack;\n  var args = argList;\n\n  var lastArg = args[args.length -1];\n  if(typeof lastArg === 'function') {\n    callBack = lastArg;\n    args = args.slice(0, args.length-1);\n  }\n\n  self._unfinishedCount++;\n\n  // Add a custom callback that checks to see if other commands are finished\n  var command = args.concat(function (err, result) {\n    if(callBack) {\n      callBack(err, result);\n    }\n\n    self._errors[index] = err;\n    self._results[index] = result;\n\n    self._unfinishedCount--;\n    if (self._unfinishedCount === 0) {\n      self._done();\n    }\n  });\n\n  self._commands.push(function () {\n    self._client[name].apply(self, command)\n  });\n};\n\n/**\n * called when all commands in the queue are finished\n */\nMulti.prototype._done = function () {\n  var callBack = this._doneCallback;\n  if (callBack) {\n    var errs = this._errors.filter(function (err) {\n      return err !== null;\n    });\n\n    if (errs.length === 0) {\n      errs = null;\n    }\n\n    callBack(errs, this._results);\n  }\n};\n\n/**\n * run all commands in the queue\n */\nMulti.prototype.exec = function (callback) {\n  this._doneCallback = callback;\n  this._commands.forEach(function (command) {\n    command();\n  });\n  return this;\n};\n\n/**\n * Make a command (higher order function)\n */\nvar makeCommands = function(names) {\n  names.forEach(function (name) {\n    Multi.prototype[name] = Multi.prototype[name.toUpperCase()] = function () {\n      this._command(name, Array.prototype.slice.call(arguments));\n      //Return this for chaining\n      return this;\n    };\n  });\n};\n\n/**\n * Mirror of all redis commands\n */\nmakeCommands([\n  'blpop',\n  'brpop',\n  'del',\n  'exists',\n  'expire',\n  'get',\n  'getset',\n  'hdel',\n  'hexists',\n  'hget',\n  'hgetall',\n  'hincrby',\n  'hincrbyfloat',\n  'hkeys',\n  'hlen',\n  'hmget',\n  'hmset',\n  'hset',\n  'hsetnx',\n  'incr',\n  'incrby',\n  'incrbyfloat',\n  'keys',\n  'lindex',\n  'llen',\n  'lpop',\n  'lpush',\n  'lpushx',\n  'lrange',\n  'lset',\n  'mget',\n  'ping',\n  'rpop',\n  'rpush',\n  'rpushx',\n  'sadd',\n  'sismember',\n  'scard',\n  'send_command',\n  'set',\n  'set',\n  'setex',\n  'setnx',\n  'smembers',\n  'srem',\n  'ttl',\n  'zadd',\n  'zcard',\n  'zcount',\n  'zincrby',\n  'zrange',\n  'zrangebyscore',\n  'zrank',\n  'zrem',\n  'zremrangebyrank',\n  'zremrangebyscore',\n  'zrevrange',\n  'zrevrank',\n  'zscore'\n]);\n\nvar multi = function (commands) {\n  var result = new Multi(this);\n  if(commands) {\n    commands.forEach(function (command) {\n      result._command(command[0], command.slice(1));\n    });\n  }\n  return result;\n};\n\nmodule.exports = multi;\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/keys.js":"﻿var patternToRegex = require('./helpers').patternToRegex;\n\n/**\n * Del\n */\nexports.del = function (mockInstance, keys, callback) {\n\n  if (!(keys instanceof Array)) {\n    keys = [keys];\n  }\n\n  var keysDeleted = 0;\n\n  for (var i = 0; i < keys.length; i++) {\n\n    if (keys[i] in mockInstance.storage) {\n\n      delete mockInstance.storage[keys[i]];\n      keysDeleted++;\n\n    }\n  }\n\n  mockInstance._callCallback(callback, null, keysDeleted);\n}\n\n/**\n * Exists\n */\nexports.exists = function (mockInstance, key, callback) {\n\n  var result = key in mockInstance.storage ? 1 : 0;\n\n  mockInstance._callCallback(callback, null, result);\n}\n\n/**\n * Expire\n */\nexports.expire = function (mockInstance, key, seconds, callback) {\n\n  var result = 0;\n\n  var obj = mockInstance.storage[key];\n\n  if (obj) {\n    var now = new Date().getTime();\n    var milli = Math.min(seconds*1000, Math.pow(2, 31) - 1);\n\n    if (mockInstance.storage[key]._expire) {\n      clearTimeout(mockInstance.storage[key]._expire);\n    }\n\n    mockInstance.storage[key].expires = new Date(now + milli);\n    mockInstance.storage[key]._expire = setTimeout(function() {\n      delete mockInstance.storage[key];\n    }, milli);\n\n    result = 1;\n  }\n\n  mockInstance._callCallback(callback, null, result);\n}\n\n/**\n * TTL\n * http://redis.io/commands/ttl\n */\nexports.ttl = function (mockInstance, key, callback) {\n  var result = 0;\n\n  var obj = mockInstance.storage[key];\n\n  if (obj) {\n    var now = new Date().getTime();\n    var expires = mockInstance.storage[key].expires instanceof Date ? mockInstance.storage[key].expires.getTime() : -1;\n    var seconds = (expires - now) / 1000;\n\n    if (seconds > 0) {\n      result = seconds;\n    } else {\n      result = -1;\n    }\n\n  } else {\n    result = -2;\n  }\n\n  mockInstance._callCallback(callback, null, result);\n};\n\n/**\n * Keys\n */\nexports.keys = function (mockInstance, pattern, callback) {\n  var regex = patternToRegex(pattern);\n  var keys = [];\n  \n  for (var key in mockInstance.storage) {\n    if (regex.test(key)) {\n      keys.push(key);\n    }\n  }\n\n  mockInstance._callCallback(callback, null, keys);\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/strings.js":"var Item = require(\"./item.js\");\n\n/**\n * Set\n */\nexports.set = function (mockInstance, key, value, callback) {\n\n  mockInstance.storage[key] = Item.createString(value);\n\n  mockInstance._callCallback(callback, null, \"OK\");\n};\n\n/**\n * Ping\n */\nexports.ping = function (mockInstance, callback) {\n\n  mockInstance._callCallback(callback, null, \"PONG\");\n};\n\n/**\n* Setnx\n*/\nexports.setnx = function (mockInstance, key, value, callback) {\n  if (key in mockInstance.storage) {\n    mockInstance._callCallback(callback, null, 0);\n  } else {\n    exports.set(mockInstance, key, value, /*callback);,*/ function() {\n      mockInstance._callCallback(callback, null, 1);\n    });\n  }\n};\n\n/**\n * Get\n */\nexports.get = function (mockInstance, key, callback) {\n\n  var value = null;\n  var err = null;\n\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== \"string\") {\n      err = new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\");\n    } else {\n      value = mockInstance.storage[key].value;\n    }\n  }\n\n  mockInstance._callCallback(callback, err, value);\n}\n\n/**\n * Getset\n */\nexports.getset = function (mockInstance, key, value, callback) {\n\n  exports.get(mockInstance, key, /*callback);,*/ function(err, oldValue) {\n    if (err) {\n      return mockInstance._callCallback(callback, err, null);\n    }\n  \n    mockInstance.storage[key] = Item.createString(value);\n\n    mockInstance._callCallback(callback, err, oldValue);\n  });\n};\n\nexports.mget = function (mockInstance) {\n\n  var keys = [];\n  var err = null;\n\n  // Build up the set of keys\n  if ('object' == typeof arguments[1]) {\n    keys = arguments[1];\n  } else {\n    for (var i = 1; i < arguments.length; i++) {\n      var key = arguments[i];\n      if ('function' !== typeof key) {\n        keys.push(key);\n      }\n    }\n  }\n\n  var values = [];\n  for (var j = 0; j < keys.length; j++) {\n    if (mockInstance.storage[keys[j]]) {\n      if (mockInstance.storage[keys[j]].type !== 'string') {\n        err = new Error(\"ERR Operation against key \" + keys[j] + \" holding wrong kind of value\");\n      } else {\n        values.push(mockInstance.storage[keys[j]].value);\n      }\n    } else {\n      values.push(null);\n    }\n  }\n\n  if ('function' === typeof arguments[arguments.length - 1]) {\n    mockInstance._callCallback(arguments[arguments.length - 1], err, values);\n  }\n\n}\n\n/**\n * Incr\n */\nexports.incr = function (mockInstance, key, callback) {\n\n  function _isInteger(s) {\n    return parseInt(s, 10) == s;\n  }\n\n  if (!mockInstance.storage[key]) {\n    var number = 0 + 1;\n    exports.set(mockInstance, key, number);\n    mockInstance._callCallback(callback, null, number);\n\n  } else if (mockInstance.storage[key].type !== \"string\") {\n    var err = new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\");\n    mockInstance._callCallback(callback, err, null);\n\n  } else if (_isInteger(mockInstance.storage[key].value)) {\n    var number = parseInt(mockInstance.storage[key].value, 10) + 1;\n    exports.set(mockInstance, key, number);\n    mockInstance._callCallback(callback, null, number);\n\n  } else {\n    var err = new Error(\"ERR value is not an integer or out of range\");\n    mockInstance._callCallback(callback, err, null);\n  }\n}\n\n/**\n * Incrby\n */\nexports.incrby = function (mockInstance, key, value, callback) {\n\n  function _isInteger(s) {\n    return parseInt(s, 10) == s;\n  }\n\n  value = parseInt(value);\n\n  if (!mockInstance.storage[key]) {\n    var number = 0 + value;\n    exports.set(mockInstance, key, number);\n    mockInstance._callCallback(callback, null, number);\n\n  } else if (mockInstance.storage[key].type !== \"string\") {\n    var err = new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\");\n    mockInstance._callCallback(callback, err, null);\n\n  } else if (_isInteger(mockInstance.storage[key].value)) {\n    var number = parseInt(mockInstance.storage[key].value, 10) + value;\n    exports.set(mockInstance, key, number);\n    mockInstance._callCallback(callback, null, number);\n\n  } else {\n    var err = new Error(\"ERR value is not an integer or out of range\");\n    mockInstance._callCallback(callback, err, null);\n  }\n}\n\n/**\n * Incrbyfloat\n */\nexports.incrbyfloat = function (mockInstance, key, value, callback) {\n\n  function _isFloat(s) {\n    return parseFloat(s, 10) == s;\n  }\n\n  if (!mockInstance.storage[key]) {\n    var number = 0 + parseFloat(value, 10);\n    exports.set(mockInstance, key, number.toString());\n    mockInstance._callCallback(callback, null, number.toString());\n\n  } else if (mockInstance.storage[key].type !== \"string\") {\n    var err = new Error(\"WRONGTYPE Operation against a key holding the wrong kind of value\");\n    mockInstance._callCallback(callback, err, null);\n\n  } else if (_isFloat(mockInstance.storage[key].value) && _isFloat(value)) {\n    var number = parseFloat(mockInstance.storage[key].value, 10) + parseFloat(value, 10);\n    exports.set(mockInstance, key, number.toString());\n    mockInstance._callCallback(callback, null, number.toString());\n\n  } else {\n    var err = new Error(\"ERR value is not a valid float\");\n    mockInstance._callCallback(callback, err, null);\n  }\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/item.js":"var EventEmitter = require('events').EventEmitter;\nvar util = require('util');\n\n/**\n * Transforms the argument to a string\n */\nvar stringify = function (value) {\n  return typeof(value) === \"object\" ?\n    JSON.stringify(value) :\n    value + '';\n};\n\n/**\n * Constructor of the main class RedisItem\n */\nvar RedisItem = function (type, expire) {\n  // We keep type so we don't have to use instanceof maybe this\n  // can be changed to something more clever\n  this.type = type || 0;\n  this.expires = expire || -1;\n};\n\n/**\n * Constructor of a string\n */\nvar RedisString = function (value, expires) {\n  RedisItem.call(this, \"string\", expires);\n  this.value = String(value);\n};\nutil.inherits(RedisString, RedisItem);\n\n/**\n * Constructor of an hash\n */\nvar RedisHash = function () {\n  RedisItem.call(this, \"hash\");\n  this.value = {};\n};\nutil.inherits(RedisHash, RedisItem);\n\n\nvar RedisList = function () {\n  RedisItem.call(this, \"list\");\n  this.value = [];\n};\nutil.inherits(RedisList, RedisItem);\n\nRedisList.prototype.rpush = function (values) {\n  for (var i = 0; i < values.length; i++) {\n    this.value.push(stringify(values[i]));\n  }\n};\n\nRedisList.prototype.lpush = function (values) {\n  for (var i = 0; i < values.length; i++) {\n    this.value.unshift(stringify(values[i]));\n  }\n};\n\nRedisList.prototype.rpop = function (value) {\n  return this.value.pop();\n};\n\nRedisList.prototype.lpop = function (value) {\n  return this.value.shift();\n};\n\n/**\n * Constructor of a set\n */\nvar RedisSet = function () {\n  RedisItem.call(this, \"set\");\n  this.value = [];\n}\nutil.inherits(RedisSet, RedisItem);\n\n/**\n * Constructor of a sortedset\n */\nvar RedisSortedSet = function () {\n  RedisItem.call(this, \"sortedset\");\n  this.value = {};\n}\nutil.inherits(RedisSortedSet, RedisItem);\n\nvar RedisItemFactory = {\n  _item: RedisItem,\n  _string: RedisString,\n  _hash: RedisHash,\n  _list: RedisList,\n  _set: RedisSet,\n  _sortedset: RedisSortedSet,\n  _stringify: stringify\n};\n\nRedisItemFactory.createString = function (elt, expire) {\n  return new RedisString(elt, expire);\n};\n\nRedisItemFactory.createHash = function () {\n  return new RedisHash();\n};\n\nRedisItemFactory.createList = function () {\n  return new RedisList();\n};\n\nRedisItemFactory.createSet = function () {\n  return new RedisSet();\n}\n\nRedisItemFactory.createSortedSet = function () {\n  return new RedisSortedSet();\n}\n\n/**\n * Export the constructor\n */\nmodule.exports = exports = RedisItemFactory;\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/hash.js":"/**\n * Module dependencies\n */\nvar Item = require(\"./item.js\");\n\n/**\n * Hget\n */\nexports.hget = function (mockInstance, hash, key, callback) {\n\n  var value = null;\n  var err = null;\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type === \"hash\") {\n      value = mockInstance.storage[hash].value[key];\n    } else {\n      err = new Error(\"ERR Operation against a key holding the wrong kind of value\");\n    }\n  }\n\n  mockInstance._callCallback(callback, err, value);\n}\n\n/**\n * Hexists\n */\nexports.hexists = function (mockInstance, hash, key, callback) {\n\n  var b = 0;\n  var err = null;\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type === \"hash\") {\n      b = mockInstance.storage[hash].value[key] ? 1 : 0;\n    } else {\n      err = new Error(\"ERR Operation against a key holding the wrong kind of value\");\n    }\n  }\n\n  mockInstance._callCallback(callback, err, b);\n}\n\n/**\n * Hdel\n */\nexports.hdel = function (mockInstance, hash, key, callback) {\n\n  var nb = 0;\n\n  //TODO: Support multiple values as key\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type === \"hash\") {\n      if (mockInstance.storage[hash].value[key]) {\n        delete mockInstance.storage[hash].value[key];\n        nb++;\n      }\n    } else {\n      err = new Error(\"ERR Operation against a key holding the wrong kind of value\");\n    }\n  }\n\n  mockInstance._callCallback(callback, null, nb);\n}\n\n/*\n * Hset\n */\nexports.hset = function (mockInstance, hash, key, value, callback) {\n  var update = false;\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type !== \"hash\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n    if (mockInstance.storage[hash].value[key]) {\n      update = true;\n    }\n  } else {\n    mockInstance.storage[hash] = Item.createHash();\n  }\n\n  mockInstance.storage[hash].value[key] = value;\n\n  mockInstance._callCallback(callback, null, update ? 0 : 1);\n};\n\n/**\n * Hsetnx\n */\nexports.hsetnx = function (mockInstance, hash, key, value, callback) {\n  if (!mockInstance.storage[hash]\n    || mockInstance.storage[hash].type !== \"hash\"\n    || !mockInstance.storage[hash].value[key]) {\n    exports.hset(mockInstance, hash, key, value, callback);\n  } else {\n    mockInstance._callCallback(callback, null, 0);\n  }\n\n};\n\n/**\n * Hincrby\n */\nexports.hincrby = function (mockInstance, hash, key, increment, callback) {\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type !== \"hash\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n  } else {\n    mockInstance.storage[hash] = Item.createHash();\n  }\n\n  if (mockInstance.storage[hash].value[key] && !/^\\d+$/.test(mockInstance.storage[hash].value[key])) {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR hash value is not an integer\"));\n  }\n\n  mockInstance.storage[hash].value[key] = parseInt(mockInstance.storage[hash].value[key]) || 0;\n\n  mockInstance.storage[hash].value[key] += increment;\n\n  mockInstance.storage[hash].value[key] += \"\"; //Because HGET returns Strings\n\n  mockInstance._callCallback(callback, null, parseInt(mockInstance.storage[hash].value[key])); //Because HINCRBY returns integers\n};\n\n/**\n * Hincrbyfloat\n */\nexports.hincrbyfloat = function (mockInstance, hash, key, increment, callback) {\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type !== \"hash\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n  } else {\n    mockInstance.storage[hash] = Item.createHash();\n  }\n\n  function isFloat(n) {\n      return n === +n && n !== (n|0);\n  }\n\n  if (mockInstance.storage[hash].value[key] && !isFloat(parseFloat(mockInstance.storage[hash].value[key]))) {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR value is not a valid float\"));\n  }\n\n  mockInstance.storage[hash].value[key] = parseFloat(mockInstance.storage[hash].value[key]) || 0;\n  mockInstance.storage[hash].value[key] += parseFloat(increment);\n  //convert to string\n  mockInstance.storage[hash].value[key] = mockInstance.storage[hash].value[key].toString();\n\n  mockInstance._callCallback(callback, null, mockInstance.storage[hash].value[key]);\n};\n\n/**\n * Hgetall\n */\nexports.hgetall = function (mockInstance, hash, callback) {\n\n  // TODO: Confirm if this should return null or empty obj when key does not exist\n  var obj = {};\n  var nb = 0;\n\n  if (mockInstance.storage[hash] && mockInstance.storage[hash].type !== \"hash\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  if (mockInstance.storage[hash]) {\n    for (var k in mockInstance.storage[hash].value) {\n      nb++;\n      obj[k] = mockInstance.storage[hash].value[k];\n    }\n  }\n\n  mockInstance._callCallback(callback, null, nb === 0 ? null : obj);\n}\n\n/**\n * Hkeys\n */\nexports.hkeys = function (mockInstance, hash, callback) {\n\n  var list = [];\n\n  if (mockInstance.storage[hash] && mockInstance.storage[hash].type !== \"hash\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  if (mockInstance.storage[hash]) {\n    for (var k in mockInstance.storage[hash].value) {\n      list.push(k);\n    }\n  }\n\n  mockInstance._callCallback(callback, null, list);\n}\n\n/**\n * Hvals\n */\nexports.hvals = function (mockInstance, hash, callback) {\n\n  var list = [];\n\n  if (mockInstance.storage[hash] && mockInstance.storage[hash].type !== \"hash\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  if (mockInstance.storage[hash]) {\n    for (var k in mockInstance.storage[hash].value) {\n      list.push(mockInstance.storage[hash].value[k]);\n    }\n  }\n\n  mockInstance._callCallback(callback, null, list);\n}\n\n/**\n * Hmset\n */\nexports.hmset = function (mockInstance, hash) {\n\n  // We require at least 3 arguments\n  // 0: mockInstance\n  // 1: hash name\n  // 2..N-2: key\n  // 3..N-1: value\n  // N: callback (optional)\n\n  var len = arguments.length;\n  if (len <= 3) {\n    return;\n  }\n\n  var callback;\n  if ('function' === typeof arguments[len - 1]) {\n    callback = arguments[len-1];\n  }\n\n  // check to see if this hash exists\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type !== \"hash\" && callback) {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n  } else {\n    mockInstance.storage[hash] = new Item.createHash();\n  }\n\n  for (var i = 2; i < len; i += 2) {\n    if (len <= (i + 1)) {\n      // should skip the callback here\n      break;\n    }\n    var k = arguments[i];\n    var v = arguments[i + 1];\n    mockInstance.storage[hash].value[k] = v;\n  }\n\n  // Do we have a callback?\n  if (callback) {\n    mockInstance._callCallback(callback, null, \"OK\");\n  }\n}\n\n/**\n * Hmget\n */\nexports.hmget = function (mockInstance) {\n\n  // We require at least 3 arguments\n  // 0: mockInstance\n  // 1: hash name\n  // 2: key/value object or first key name\n  if (arguments.length <= 3) {\n    return;\n  }\n\n  var keyValuesToGet = [];\n\n  for (var i = 2; i < arguments.length; i++) {\n\n    // Neither key nor value is a callback\n    if ('function' !== typeof arguments[i] && 'function' !== typeof arguments[i]) {\n\n      keyValuesToGet.push(arguments[i]);\n\n    } else {\n      break;\n    }\n  }\n\n  var keyValues = [];\n  var hash = arguments[1];\n\n  if (mockInstance.storage[hash]) {\n    if (mockInstance.storage[hash].type !== \"hash\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    } else {\n      for (var k in keyValuesToGet) {\n        keyValues.push(mockInstance.storage[hash].value[keyValuesToGet[k]])\n      }\n    }\n  } else {\n    for (var k in keyValuesToGet) {\n      keyValues.push(null)\n    }\n  }\n\n  // Do we have a callback?\n  if ('function' === typeof arguments[arguments.length - 1]) {\n    mockInstance._callCallback(arguments[arguments.length - 1], null, keyValues);\n  }\n}\n\n/**\n * Hlen\n */\nexports.hlen = function (mockInstance, hash, callback) {\n\n  if (!mockInstance.storage[hash]) {\n    return mockInstance._callCallback(callback, null, 0);\n  }\n  if (mockInstance.storage[hash].type !== \"hash\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  var cnt = 0;\n  for (var p in mockInstance.storage[hash].value) {\n    if (mockInstance.storage[hash].value.hasOwnProperty(p)) {\n      cnt++;\n    }\n  }\n\n  mockInstance._callCallback(callback, null, cnt);\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/list.js":"var helpers = require(\"./helpers.js\");\nvar Item = require(\"./item.js\");\n\n\nvar mockCallback = helpers.mockCallback;\n\nvar validKeyType = function(mockInstance, key, callback) {\n  return helpers.validKeyType(mockInstance, key, 'list', callback)\n};\n\nvar initKey = function(mockInstance, key) {\n  return helpers.initKey(mockInstance, key, Item.createList);\n};\n\n/**\n * Llen\n */\nexports.llen = function (mockInstance, key, callback) {\n  var length = mockInstance.storage[key] ? mockInstance.storage[key].value.length : 0;\n  mockInstance._callCallback(callback, null, length);\n};\n\nvar push = function (fn, args) {\n  var len = args.length;\n  if (len < 2) {\n    return\n  }\n  var mockInstance = args[0];\n  var key = args[1];\n  var callback = helpers.parseCallback(args);\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  // init key\n  initKey(mockInstance, key);\n\n  // parse only the values from the args;\n  var values = [];\n  for (var i=2, val; i < len; i++) {\n    val = args[i];\n    if ('function' == typeof val) {\n      break;\n    }\n    values.push(val);\n  }\n  fn.call(mockInstance.storage[key], values);\n  var length = mockInstance.storage[key].value.length;\n  pushListWatcher.pushed(key);\n  mockInstance._callCallback(callback, null, length);\n};\n\n/**\n * Lpush\n */\nexports.lpush = function () {\n  push(Item._list.prototype.lpush, arguments);\n};\n\n/**\n * Rpush\n */\nexports.rpush = function () {\n  push(Item._list.prototype.rpush, arguments);\n};\n\nvar pushx = function (fn, mockInstance, key, value, callback) {\n  var length = 0;\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== \"list\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n    fn.call(mockInstance.storage[key], [value]);\n    length = mockInstance.storage[key].value.length;\n    pushListWatcher.pushed(key);\n  }\n  mockInstance._callCallback(callback, null, length);\n};\n\n/**\n * Rpushx\n */\nexports.rpushx = function (mockInstance, key, value, callback) {\n  pushx(Item._list.prototype.rpush, mockInstance, key, value, callback);\n};\n\n/**\n * Lpushx\n */\nexports.lpushx = function (mockInstance, key, value, callback) {\n  pushx(Item._list.prototype.lpush, mockInstance, key, value, callback);\n};\n\nvar pop = function (fn, mockInstance, key, callback) {\n  var val = null;\n  if (mockInstance.storage[key] && mockInstance.storage[key].type !== \"list\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  if (mockInstance.storage[key] && mockInstance.storage[key].value.length > 0) {\n    val = fn.call(mockInstance.storage[key]);\n  }\n  mockInstance._callCallback(callback, null, val);\n};\n\n/**\n * Lpop\n */\nexports.lpop = function (mockInstance, key, callback) {\n  pop.call(this, Item._list.prototype.lpop, mockInstance, key, callback);\n};\n\n/**\n * Rpop\n */\nexports.rpop = function (mockInstance, key, callback) {\n  pop.call(this, Item._list.prototype.rpop, mockInstance, key, callback);\n};\n\n/**\n * Listen to all the list identified by keys and set a timeout if timeout != 0\n */\nvar listenToPushOnLists = function (mockInstance, keys, timeout, callback) {\n  var listenedTo = [];\n  var expire = null;\n  var listener = function (key) {\n    // We remove all the other listeners.\n    pushListWatcher.removeListeners(listenedTo, listener);\n    if (expire) {\n      clearTimeout(expire);\n    }\n    callback(key);\n  };\n\n  for (var i = 0; i < keys.length; i++) {\n    listenedTo.push(keys[i]);\n    pushListWatcher.suscribe(keys[i], listener);\n  }\n  if (timeout > 0) {\n    expire = setTimeout(function () {\n      pushListWatcher.removeListeners(listenedTo, listener);\n      callback(null);\n    }, timeout * 1000);\n  }\n};\n\n/**\n * Helper function to build blpop and brpop\n */\nvar bpop = function (fn, mockInstance, keys, timeout, callback) {\n  var val = null;\n  // Look if any element can be returned\n  for (var i = 0; i < keys.length; i++) {\n    if (mockInstance.storage[keys[i]] && mockInstance.storage[keys[i]].value.length > 0) {\n      val = fn.call(mockInstance.storage[keys[i]]);\n      mockInstance._callCallback(callback, null, val);\n      return;\n    }\n  }\n  // We listen to all the list we asked for\n  listenToPushOnLists(mockInstance, keys, timeout, function (key) {\n    if (key !== null) {\n      val = fn.call(mockInstance.storage[key]);\n      mockInstance._callCallback(callback, null, [key, val]);\n    } else {\n      mockInstance._callCallback(callback, null, null);\n    }\n\n  });\n};\n\n/**\n * BLpop\n */\nexports.blpop = function (mockInstance, keys, timeout, callback) {\n  bpop.call(this, Item._list.prototype.lpop, mockInstance, keys, timeout, callback);\n};\n\n/**\n * BRpop\n */\nexports.brpop = function (mockInstance, keys, timeout, callback) {\n  bpop.call(this, Item._list.prototype.rpop, mockInstance, keys, timeout, callback);\n};\n\n/**\n * Lindex\n */\nexports.lindex = function (mockInstance, key, index, callback) {\n  var val = null;\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== \"list\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n\n    if (index < 0 && -mockInstance.storage[key].value.length <= index) {\n      val = mockInstance.storage[key].value[mockInstance.storage[key].value.length + index];\n    } else if (mockInstance.storage[key].value.length > index) {\n      val = mockInstance.storage[key].value[index];\n    }\n  }\n  mockInstance._callCallback(callback, null, val);\n};\n\n/**\n * Lrange\n */\nexports.lrange = function (mockInstance, key, startIndex, stopIndex, callback) {\n  var val = [];\n  var index1 = startIndex;\n  var index2 = stopIndex;\n\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== \"list\") {\n      return mockInstance._callCallback(callback,\n        new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n    }\n\n    index1 = index1 >= 0 ? index1 : Math.max(mockInstance.storage[key].value.length + index1, 0);\n    index2 = index2 >= 0 ? index2 : Math.max(mockInstance.storage[key].value.length + index2, 0);\n    val = mockInstance.storage[key].value.slice(index1, index2 + 1);\n  }\n  mockInstance._callCallback(callback, null, val);\n};\n\n/**\n * Lset\n */\nexports.lset = function (mockInstance, key, index, value, callback) {\n  var res = \"OK\";\n  var len = -1;\n  if (!mockInstance.storage[key]) {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR no such key\"));\n  }\n  if (mockInstance.storage[key].type !== \"list\") {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR Operation against a key holding the wrong kind of value\"));\n  }\n  len = mockInstance.storage[key].value.length;\n  if (len <= index || -len > index) {\n    return mockInstance._callCallback(callback,\n      new Error(\"ERR index out of range\"));\n  }\n  if (index < 0) {\n    mockInstance.storage[key].value[len + index] = Item._stringify(value);\n  } else {\n    mockInstance.storage[key].value[index] = Item._stringify(value);\n  }\n  mockInstance._callCallback(callback, null, res);\n};\n\n/**\n * Used to follow a list depending on its key (used by blpop and brpop mainly)\n */\nvar PushListWatcher = function () {\n  this.listeners = {};\n};\n\n/**\n * Watch for the next push in the list key\n */\nPushListWatcher.prototype.suscribe = function (key, listener) {\n  if (this.listeners[key]) {\n    this.listeners[key].push(listener);\n  } else {\n    this.listeners[key] = [listener];\n  }\n};\n\n/**\n * Calls the first listener which was waiting for an element\n * to call when we push to a list\n */\nPushListWatcher.prototype.pushed = function (key) {\n  if (this.listeners[key] && this.listeners[key].length > 0) {\n    var listener = this.listeners[key].shift();\n    listener(key);\n  }\n};\n\n/**\n * Remove all the listener from all the keys it was listening to\n */\nPushListWatcher.prototype.removeListeners = function (listenedTo, listener) {\n  for (var i = 0; i < listenedTo.length; i++) {\n    for (var j = 0; j < this.listeners[listenedTo[i]].length; j++) {\n      if (this.listeners[listenedTo[i]][j] === listener) {\n        this.listeners[listenedTo[i]].splice(j, 1);\n        j = this.listeners[listenedTo[i]];\n      }\n    }\n  }\n};\n\nvar pushListWatcher = new PushListWatcher();\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/set.js":"var Item = require('./item.js');\n\n/**\n * Sadd\n */\nexports.sadd = function (mockInstance, key, members, callback) {\n  if (mockInstance.storage[key] && mockInstance.storage[key].type !== 'set') {\n    var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n    return mockInstance._callCallback(callback, err);\n  }\n\n  mockInstance.storage[key] = mockInstance.storage[key] || new Item.createSet();\n\n  var set = mockInstance.storage[key].value;\n  var addCount = 0;\n  for (var i = 0; i < members.length; i++) {\n    if (set.indexOf(Item._stringify(members[i])) < 0) {\n      set.push(Item._stringify(members[i]));\n      addCount++;\n    }\n  }\n\n  mockInstance._callCallback(callback, null, addCount);\n}\n\n/**\n * Srem\n */\nexports.srem = function (mockInstance, key, members, callback) {\n  var remCount = 0;\n\n  if (mockInstance.storage[key]) {\n\n    if (mockInstance.storage[key].type !== 'set') {\n      var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n      return mockInstance._callCallback(callback, err);\n\n    } else {\n      var set = mockInstance.storage[key].value;\n      for (var i = 0; i < members.length; i++) {\n        for (var j = 0; j < set.length; j++) {\n          if (set[j] == Item._stringify(members[i])) {\n            set.splice(j, 1);\n            remCount++;\n          }\n        }\n      }\n    }\n  }\n\n  mockInstance._callCallback(callback, null, remCount);\n}\n\n/**\n * Smembers\n */\nexports.smembers = function (mockInstance, key, callback) {\n  var members = null;\n\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== 'set') {\n      var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n      return mockInstance._callCallback(callback, err);\n    } else {\n      members = mockInstance.storage[key].value;\n    }\n  }\n\n  mockInstance._callCallback(callback, null, members);\n}\n\n/**\n * Sismember\n */\nexports.sismember = function (mockInstance, key, member, callback) {\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== 'set') {\n      var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n      return mockInstance._callCallback(callback, err);\n    }\n  }\n  member = Item._stringify(member);\n  var count = (mockInstance.storage[key].value.indexOf(member) > -1) ? 1 : 0;\n  mockInstance._callCallback(callback, null, count);\n}\n\n/**\n * Scard\n */\nexports.scard = function (mockInstance, key, callback) {\n  var count = 0;\n\n  if (mockInstance.storage[key]) {\n    if (mockInstance.storage[key].type !== 'set') {\n      var err = new Error('WRONGTYPE Operation against a key holding the wrong kind of value');\n      return mockInstance._callCallback(callback, err);\n    } else {\n      var set = mockInstance.storage[key].value;\n      count = set.length;\n    }\n  }\n\n  mockInstance._callCallback(callback, null, count);\n}","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/sortedset.js":"var helpers = require(\"./helpers.js\");\nvar Item = require(\"./item.js\");\n\n/**\n\n  *** NOT IMPLEMENTED ***\n\n  ZINTERSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n  Intersect multiple sorted sets and store the resulting sorted set in a new key\n\n  ZLEXCOUNT key min max\n  Count the number of members in a sorted set between a given lexicographical range\n\n  ZRANGEBYLEX key min max [LIMIT offset count]\n  Return a range of members in a sorted set, by lexicographical range\n\n  ZREVRANGEBYLEX key max min [LIMIT offset count]\n  Return a range of members in a sorted set, by lexicographical range, ordered from higher to lower strings.\n\n  ZREMRANGEBYLEX key min max\n  Remove all members in a sorted set between the given lexicographical range\n\n  ZUNIONSTORE destination numkeys key [key ...] [WEIGHTS weight [weight ...]] [AGGREGATE SUM|MIN|MAX]\n  Add multiple sorted sets and store the resulting sorted set in a new key\n\n  ZSCAN key cursor [MATCH pattern] [COUNT count]\n  Incrementally iterate sorted sets elements and associated scores\n\n*/\n\nvar MAX_SCORE_VALUE = 9007199254740992;\nvar MIN_SCORE_VALUE = -MAX_SCORE_VALUE;\n\nvar mockCallback = helpers.mockCallback;\n\nvar validKeyType = function(mockInstance, key, callback) {\n  return helpers.validKeyType(mockInstance, key, 'sortedset', callback)\n}\n\nvar initKey = function(mockInstance, key) {\n  return helpers.initKey(mockInstance, key, Item.createSortedSet);\n}\n\n// delimiter for lexicographically sorting by score & member\nvar rankedDelimiter = '#';\n\n/*\nReturns a sorted set of all the score+members for a key\n*/\nvar getRankedList = function(mockInstance, key) {\n  // returns a ranked list of items (k)\n  var items = [];\n  for (var member in mockInstance.storage[key].value) {\n    var score = mockInstance.storage[key].value[member];\n    items.push(score + rankedDelimiter + member);\n  }\n  items.sort();\n  return items;\n}\n\n/*\ngetRank (zrank & zrevrank)\n*/\nvar getRank = function(mockInstance, key, member, callback, reversed) {\n\n var len = arguments.length;\n  if (len <= 3) {\n    return\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  initKey(mockInstance, key);\n  member = Item._stringify(member);\n  var rank = null;\n  var ranked = getRankedList(mockInstance, key);\n\n  // this is for zrevrank\n  if (reversed) {\n    ranked.reverse();\n  }\n\n  for (var i=0, parts, s, m; i < ranked.length; i++) {\n    parts = ranked[i].split(rankedDelimiter);\n    s = parts[0];\n    m = parts.slice(1).join(rankedDelimiter);\n    if (m === member) {\n      rank = i;\n      break;\n    }\n  }\n  mockInstance._callCallback(callback, null, rank);\n\n}\n\n/*\ngetRange (zrange & zrevrange)\n*/\nvar getRange = function(mockInstance, key, start, stop, withscores, callback, reversed) {\n  var len = arguments.length;\n  if (len < 4) {\n    return\n  }\n  if ('function' === typeof withscores) {\n    callback = withscores;\n    withscores = undefined;\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n\n  initKey(mockInstance, key);\n  var ranked = getRankedList(mockInstance, key);\n\n  // this is for zrevrange\n  if (reversed) {\n    ranked.reverse();\n  }\n\n  // convert to string so we can test for inclusive range\n  start = parseInt(String(start), 10);\n  stop = parseInt(String(stop), 10);\n\n  if (start < 0) {\n    start = ranked.length + start;\n  }\n  if (stop < 0) {\n    stop = ranked.length + stop;\n  }\n\n  // start must be less then stop\n  if (start > stop) {\n    return mockInstance._callCallback(callback, null, []);\n  }\n  // console.log(ranked, start, stop + 1);\n\n  // make slice inclusive\n  ranked = ranked.slice(start, stop + 1);\n\n  var range = [], mintest, maxtest;\n  for (var i=0, parts, s, score, m; i < ranked.length; i++) {\n    parts = ranked[i].split(rankedDelimiter);\n    s = parts[0];\n    score = parseFloat(s);\n    m = parts.slice(1).join(rankedDelimiter);\n    range.push(m);\n    if (withscores && withscores.toLowerCase() === 'withscores') {\n      range.push(s);\n    }\n  }\n  mockInstance._callCallback(callback, null, range);\n}\n\n/**\ngetRangeByScore (zrangebyscore & zrevrangebyscore)\n**/\nvar getRangeByScore = function(\n  mockInstance,\n  key,\n  min,\n  max,\n  withscores,\n  limit,\n  offset,\n  count,\n  callback,\n  reversed) {\n\n  var len = arguments.length;\n  if (len < 4) {\n    return\n  }\n  if ('function' === typeof withscores) {\n    callback = withscores;\n    withscores = undefined;\n  }\n  if ('function' === typeof limit) {\n    callback = limit;\n    limit = undefined;\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n\n  initKey(mockInstance, key);\n\n  var ranked = getRankedList(mockInstance, key);\n  if (reversed) {\n    ranked.reverse();\n  }\n\n  // check for infinity flags\n  if (min.toString() === '-inf') {\n    min = MIN_SCORE_VALUE;\n  }\n  if (max.toString() === '+inf') {\n    max = MAX_SCORE_VALUE;\n  }\n  // handles the reversed case\n  if (min.toString() === '+inf') {\n    min = MAX_SCORE_VALUE;\n  }\n  if (max.toString() === '-inf') {\n    max = MIN_SCORE_INTEGER;\n  }\n\n  // convert to string so we can test for inclusive range\n  min = String(min);\n  max = String(max);\n\n  // ranges inclusive?\n  var minlt = false;\n  var maxlt = false;\n  if (min[0] === '(') {\n    min = min.substring(1);\n    minlt = true;\n  }\n  if (max[0] === '(') {\n    max = max.substring(1);\n    maxlt = true;\n  }\n  // convert to float\n  min = parseFloat(min);\n  max = parseFloat(max);\n\n  // console.log('checkpoint', ranked, min, max, withscores, callback, minlt, maxlt);\n  var range = [], mintest, maxtest;\n  for (var i=0, parts, s, score, m; i < ranked.length; i++) {\n    parts = ranked[i].split(rankedDelimiter);\n    s = parts[0];\n    score = parseFloat(s);\n    mintest = (minlt) ? (min < score) : (min <= score);\n    maxtest = (maxlt) ? (score < max) : (score <= max);\n\n    // console.log('test', s, score, mintest, maxtest);\n    if (!mintest || !maxtest) {\n      continue;\n    }\n    m = parts.slice(1).join(rankedDelimiter);\n    range.push(m);\n    if (withscores && withscores.toLowerCase() === 'withscores') {\n      // score as string\n      range.push(s);\n    }\n  }\n  // console.log('range', range);\n  // do we need to slice the out put?\n  if (limit && limit.toLowerCase() === 'limit' && offset && count) {\n    offset = parseInt(offset, 10);\n    count = parseInt(count, 10);\n    // withscores needs to adjust the offset and count\n    if (withscores && withscores.toLowerCase() === 'withscores') {\n      offset *= 2;\n      count *= 2;\n    }\n    range = range.slice(offset, offset + count);\n  }\n\n  mockInstance._callCallback(callback, null, range);\n\n}\n\n// ZADD key [NX|XX] [CH] [INCR] score member [score member ...]\n// Add one or more members to a sorted set, or update its score if it already exists\nexports.zadd = function(mockInstance, key) {\n\n  var len = arguments.length;\n  if (len <= 3) {\n    return\n  }\n  var callback = helpers.parseCallback(arguments);\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  // init key\n  initKey(mockInstance, key);\n\n  // declare opts\n  var nx = false, xx = false, ch = false, incr = false;\n  var start = 2, count = 0;\n\n  for (var i=start; i < len; i++) {\n    var opt = arguments[i];\n    opt = opt.toString().toLowerCase();\n    // Don't update already existing elements. Always add new elements.\n    if (opt === 'nx') {\n      nx = true;\n      continue;\n    }\n    // Only update elements that already exist. Never add elements.\n    if (opt === 'xx') {\n      xx = true;\n      continue;\n    }\n    // Total number of elements changed\n    if (opt === 'ch') {\n      ch = true;\n      continue;\n    }\n    if (opt === 'incr') {\n      incr = true;\n      continue;\n    }\n    start = i;\n    break;\n\n  }\n\n  for (var i = start; i < len; i += 2) {\n    // hold the score and make sure it isn't an opt\n    var score = arguments[i];\n\n    // did we reach the end?\n    if (len <= (i + 1)) {\n        break;\n    }\n    var member = Item._stringify(arguments[i + 1]);\n    var existingScore = mockInstance.storage[key].value[member];\n    var exists = existingScore != undefined;\n\n    // process opts\n    if ((nx && exists) || (xx && !exists)) {\n      continue;\n    }\n    // convert score to string\n    score = score.toString();\n\n    // updating score if memeber doesn't exist\n    // or if ch = true and score changes\n    if (!exists || (ch && existingScore != score)) {\n      count += 1;\n    }\n\n    // do we need to incr (existing score + score)?\n    if (incr && existingScore) {\n      score = parseFloat(existingScore) + parseFloat(score);\n      score = String(score);\n    }\n\n    // update score\n    mockInstance.storage[key].value[member] = score;\n\n    // only one member is allowed update\n    // if we have an incr\n    // this shold behave the same as zincrby\n    // so return the score instead of the updatedCount;\n    if (incr) {\n      count = score;\n      break;\n    }\n  }\n\n  if (callback) {\n    mockInstance._callCallback(callback, null, count);\n  }\n}\n\n// ZCARD key\n// Get the number of members in a sorted set\nexports.zcard = function(mockInstance, key, callback) {\n  var len = arguments.length;\n  if (len < 1) {\n    return\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  initKey(mockInstance, key);\n  var count = Object.keys(mockInstance.storage[key].value).length;\n  mockInstance._callCallback(callback, null, count);\n}\n\n// ZCOUNT key min max\n// Count the members in a sorted set with scores within the given values\nexports.zcount = function(mockInstance, key, min, max, callback) {\n  var parse = function(err, result) {\n    if (err) {\n      return mockInstance._callCallback(callback, err);\n    }\n    mockInstance._callCallback(callback, null, result.length);\n  }\n  exports.zrangebyscore(mockInstance, key, min, max, parse);\n}\n\n// ZINCRBY key increment member\n// Increment the score of a member in a sorted set\nexports.zincrby = function(mockInstance, key, increment, member, callback) {\n  var len = arguments.length;\n  if (len < 4) {\n    return\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  initKey(mockInstance, key);\n  member = Item._stringify(member);\n  var s = mockInstance.storage[key].value[member];\n  var score = parseFloat( s !== undefined ? s : '0');\n  increment = parseFloat(String(increment));\n  score += increment;\n  score = String(score);\n  mockInstance.storage[key].value[member] = score;\n  mockInstance._callCallback(callback, null, score);\n}\n\n// ZRANGE key start stop [WITHSCORES]\n// Return a range of members in a sorted set, by index\nexports.zrange = function(mockInstance, key, start, stop, withscores, callback) {\n  getRange(mockInstance, key, start, stop, withscores, callback, false);\n}\n\n// ZRANGEBYSCORE key min max [WITHSCORES] [LIMIT offset count]\n// Return a range of members in a sorted set, by score\nexports.zrangebyscore = function(\n  mockInstance,\n  key,\n  min,\n  max,\n  withscores,\n  limit,\n  offset,\n  count,\n  callback) {\n\n  getRangeByScore(\n    mockInstance,\n    key,\n    min,\n    max,\n    withscores,\n    limit,\n    offset,\n    count,\n    callback,\n    false);\n\n};\n\n// ZRANK key member\n// Determine the index of a member in a sorted set\nexports.zrank = function(mockInstance, key, member, callback) {\n  getRank(mockInstance, key, member, callback, false);\n}\n\n// ZREM key member [member ...]\n// Remove one or more members from a sorted set\nexports.zrem = function(mockInstance, key) {\n  var len = arguments.length;\n  if (len <= 3) {\n    return\n  }\n\n  var callback = helpers.parseCallback(arguments);\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  initKey(mockInstance, key);\n  // The number of members removed from the sorted set,\n  // not including non existing members.\n  var count = 0;\n  for (var i=2, member; i < len; i++) {\n    member = arguments[i];\n    if ('function' == typeof member) {\n      break;\n    }\n    member = Item._stringify(member);\n    if (mockInstance.storage[key].value[member]) {\n      delete mockInstance.storage[key].value[member];\n      count += 1;\n    }\n  }\n  mockInstance._callCallback(callback, null, count);\n}\n\n// ZREMRANGEBYRANK key start stop\n// Remove all members in a sorted set within the given indexes\nexports.zremrangebyrank = function(mockInstance, key, start, stop, callback) {\n\n  var deleteResults = function(err, results) {\n    if (err) {\n      return mockInstance._callCallback(callback, err);\n    }\n    var count = 0;\n    for (var i=0, member; i < results.length; i++) {\n      member = results[i];\n      if (mockInstance.storage[key].value[member]) {\n        delete mockInstance.storage[key].value[member];\n        count += 1;\n      }\n    }\n    mockInstance._callCallback(callback, null, count);\n  }\n  getRange(mockInstance, key, start, stop, deleteResults, false);\n}\n\n// ZREMRANGEBYSCORE key min max\n// Remove all members in a sorted set within the given scores\nexports.zremrangebyscore = function(mockInstance, key, min, max, callback) {\n\n  var deleteResults = function(err, results) {\n    if (err) {\n      return mockInstance._callCallback(callback, err);\n    }\n    var count = 0;\n    for (var i=0, member; i < results.length; i++) {\n      member = results[i];\n      if (mockInstance.storage[key].value[member]) {\n        delete mockInstance.storage[key].value[member];\n        count += 1;\n      }\n    }\n    mockInstance._callCallback(callback, null, count);\n  }\n  getRangeByScore(mockInstance, key, min, max, deleteResults, false);\n}\n\n\n// ZREVRANGE key start stop [WITHSCORES]\n// Return a range of members in a sorted set, by index, with scores ordered from high to low\nexports.zrevrange = function(mockInstance, key, start, stop, withscores, callback) {\n  getRange(mockInstance, key, start, stop, withscores, callback, true);\n}\n\n// ZREVRANGEBYSCORE key max min [WITHSCORES] [LIMIT offset count]\n// Return a range of members in a sorted set, by score, with scores ordered from high to low\nexports.zrevrangebyscore = function(\n  mockInstance,\n  key,\n  max,\n  min,\n  withscores,\n  limit,\n  offset,\n  count,\n  callback) {\n\n  getRangeByScore(\n    mockInstance,\n    key,\n    min,\n    max,\n    withscores,\n    limit,\n    offset,\n    count,\n    callback,\n    true);\n};\n\n// ZREVRANK key member\n// Determine the index of a member in a sorted set, with scores ordered from high to low\nexports.zrevrank = function(mockInstance, key, member, callback) {\n  getRank(mockInstance, key, member, callback, true);\n}\n\n// ZSCORE key member\n// Get the score associated with the given member in a sorted set\nexports.zscore = function(mockInstance, key, member, callback) {\n  var len = arguments.length;\n  if (len < 3) {\n    return\n  }\n  if (callback == undefined) {\n    callback = mockCallback;\n  }\n  if (!validKeyType(mockInstance, key, callback)) {\n    return\n  }\n  initKey(mockInstance, key);\n  var score = mockInstance.storage[key].value[Item._stringify(member)];\n  mockInstance._callCallback(callback, null, score);\n}\n","/home/travis/build/npmtest/node-npmtest-redis-mock/node_modules/redis-mock/lib/server.js":"/**\n * flushdb\n */\nvar flushdb = exports.flushdb = function (mockInstance, callback) {\n  mockInstance.storage = {};\n\n  mockInstance._callCallback(callback, null, 'OK');\n}\n\n/**\n * flushall\n * Exact the same as flushdb because multiple db is not supported yet\n */\nexports.flushall = flushdb;\n\n/**\n * auth\n */\nexports.auth = function auth(mockInstance, password, callback) {\n  mockInstance._callCallback(callback, null, 'OK');\n}\n"}